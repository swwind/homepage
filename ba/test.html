<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      html,
      body {
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: black;
        color: white;
        user-select: none;
        height: 100%;
        width: 100%;
      }

      #canvas {
        position: fixed;
        left: 0;
        top: 0;
        z-index: 100;
        pointer-events: none;
      }

      video {
        height: 100%;
        width: 100%;
        object-fit: cover;
      }
    </style>
  </head>
  <body>
    <video src="title-vp9.mp4" autoplay muted loop></video>
    <canvas id="canvas"></canvas>
    <script>
      const MOUSE_TIME = 250;
      const TRIANGLE_TIME = 750;
      const TRIANGLE_DISTANT = 100;

      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      if (!ctx) {
        throw new Error("canvas is disabled");
      }

      function onresize() {
        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;
      }
      addEventListener("resize", onresize);
      onresize();

      /** @type {{x: number, y: number}[]} */
      const circles = [];
      /** @type {{t: number, x1: number, y1: number, x2: number, y2: number}[]} */
      const moves = [];
      /** @type {{t: number, x: number, y: number, a: number, u: boolean, s: number}[]} */
      const triangles = [];

      /**
       * @param {number} x
       * @param {number} y
       */
      function addCircle(x, y) {
        circles.push({ x, y });
        setTimeout(() => circles.shift(), 1000);
        addTriangle(x, y);
        addTriangle(x, y);
        addTriangle(x, y);
      }

      /**
       * @param {number} x1
       * @param {number} y1
       * @param {number} x2
       * @param {number} y2
       */
      function addMovement(x1, y1, x2, y2) {
        moves.push({ x1, y1, x2, y2, t: Date.now() });
        setTimeout(() => moves.shift(), MOUSE_TIME);
        // make triangles
        const d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        let i = 1;
        while (distance + d >= TRIANGLE_DISTANT * i) {
          const k = TRIANGLE_DISTANT * i++ - distance; // 0 <= k <= d
          const nx = (x1 * (d - k) + x2 * k) / d;
          const ny = (y1 * (d - k) + y2 * k) / d;
          addTriangle(nx, ny);
        }
        distance = distance + d - TRIANGLE_DISTANT * (i - 1);
      }

      /**
       * @param {number} x
       * @param {number} y
       */
      function addTriangle(x, y) {
        triangles.push({
          x,
          y,
          t: Date.now(),
          a: Math.random() * Math.PI * 2,
          u: Math.random() < 0.5,
          s: Math.random(),
        });
        setTimeout(() => triangles.shift(), TRIANGLE_TIME);
      }

      let mousedown = false;
      let lastX = 0;
      let lastY = 0;
      let distance = 0;

      addEventListener("mousedown", (e) => {
        addCircle(e.x, e.y);
        mousedown = true;
        lastX = e.x;
        lastY = e.y;
      });

      addEventListener("mouseup", () => {
        mousedown = false;
      });

      addEventListener("mousemove", (e) => {
        if (mousedown) {
          addMovement(lastX, lastY, e.x, e.y);
          lastX = e.x;
          lastY = e.y;
        }
      });

      let touchX = 0;
      let touchY = 0;

      addEventListener("touchstart", (e) => {
        addCircle(e.touches[0].clientX, e.touches[0].clientY);
        touchX = e.touches[0].clientX;
        touchY = e.touches[0].clientY;
      });

      addEventListener("touchmove", (e) => {
        addMovement(touchX, touchY, e.touches[0].clientX, e.touches[0].clientY);
        touchX = e.touches[0].clientX;
        touchY = e.touches[0].clientY;
      });

      const sqrt3to2 = Math.sqrt(3) / 2;
      const szFn = (life) => {
        const st = Math.sqrt(life);
        return st * (1 - st) * 4;
      };
      const mixRgba = (c1, c2, p) => {
        const r = c1[0] * p + c2[0] * (1 - p);
        const g = c1[1] * p + c2[1] * (1 - p);
        const b = c1[2] * p + c2[2] * (1 - p);
        const a = c1[3] * p + c2[3] * (1 - p);
        return `rgba(${r}, ${g}, ${b}, ${a})`;
      };

      requestAnimationFrame(function render() {
        const now = Date.now();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // draw circles
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;
        ctx.strokeStyle = "white";
        for (const c of circles) {
          ctx.beginPath();
          ctx.arc(c.x, c.y, 20, 0, Math.PI * 2);
          ctx.stroke();
        }

        // draw line shadows
        ctx.shadowColor = "#99F3EF";
        ctx.strokeStyle = "#fff";
        for (const m of moves) {
          const life = Math.min((now - m.t) / MOUSE_TIME, 1);
          const size = Math.sqrt(1 - life);

          for (let i = 0; i < 3; ++i) {
            ctx.beginPath();
            ctx.moveTo(m.x1, m.y1);
            ctx.lineTo(m.x2, m.y2);
            ctx.shadowBlur = 5 * size * size * size * size;
            ctx.lineWidth = 3 * size * size * size * size + 1;
            ctx.stroke();
          }
        }

        // draw lines
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "#fff";
        for (const m of moves) {
          const life = Math.min((now - m.t) / MOUSE_TIME, 1);
          const size = Math.sqrt(1 - life);

          ctx.beginPath();
          ctx.moveTo(m.x1, m.y1);
          ctx.lineTo(m.x2, m.y2);
          ctx.lineWidth = 3 * size * size * size * size + 1;
          ctx.stroke();
        }

        // draw triangles
        for (const t of triangles) {
          const life = (now - t.t) / TRIANGLE_TIME;
          const ox = t.x + (life * 20 + 40) * Math.cos(t.a);
          const oy = t.y + (life * 20 + 40) * Math.sin(t.a);
          const s = (t.s * 5 + 15) * szFn(life);

          ctx.beginPath();
          ctx.moveTo(ox - s / 2, oy);
          ctx.lineTo(ox, oy + (t.u ? sqrt3to2 : -sqrt3to2) * s);
          ctx.lineTo(ox + s / 2, oy);
          ctx.fillStyle = mixRgba(
            [0xff, 0xff, 0xff, 0.8],
            [0x99, 0xf3, 0xef, 0.5],
            Math.cos((t.t + now) / 50)
          );
          ctx.fill();
        }

        requestAnimationFrame(render);
      });
    </script>
  </body>
</html>
